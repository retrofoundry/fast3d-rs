use std::{
    collections::hash_map::DefaultHasher,
    hash::{Hash, Hasher},
};

use self::defines::{BlendState, CompareFunction, Face};

use super::{
    rdp::NUM_TILE_DESCRIPTORS,
    utils::{
        color_combiner::CombineParams,
        texture::{ImageFormat, ImageSize},
        texture_cache::TextureCache,
        tile_descriptor::TileDescriptor,
    },
};

pub mod defines;

const TEXTURE_CACHE_MAX_SIZE: usize = 500;

pub struct GraphicsIntermediateTexture {
    pub game_address: usize,
    pub format: ImageFormat,
    pub size: ImageSize,
    pub width: u32,
    pub height: u32,
    pub data: Vec<u8>,

    // when a texture has been created in a gfx backend, this field will be Some
    pub device_id: Option<u32>,
}

impl GraphicsIntermediateTexture {
    pub fn new(
        game_address: usize,
        format: ImageFormat,
        size: ImageSize,
        width: u32,
        height: u32,
        data: Vec<u8>,
    ) -> Self {
        Self {
            game_address,
            format,
            size,
            width,
            height,
            data,
            device_id: None,
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub struct GraphicsIntermediateSampler {
    pub tile: usize,
    pub linear_filter: bool,
    pub clamp_s: u32,
    pub clamp_t: u32,
}

#[derive(Debug, Clone, Copy)]
pub struct GraphicsIntermediateStencil {
    pub depth_write_enabled: bool,
    pub depth_compare: CompareFunction,
    pub polygon_offset: bool,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct GraphicsIntermediateUniformsBlend {
    pub fog_color: glam::Vec4,
    pub blend_color: glam::Vec4,
}

impl GraphicsIntermediateUniformsBlend {
    pub const EMPTY: Self = GraphicsIntermediateUniformsBlend {
        fog_color: glam::Vec4::ZERO,
        blend_color: glam::Vec4::ZERO,
    };
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct GraphicsIntermediateUniformsCombine {
    pub prim_color: glam::Vec4,
    pub env_color: glam::Vec4,
    pub key_center: glam::Vec3,
    pub key_scale: glam::Vec3,
    pub prim_lod: glam::Vec2,
    pub convert_k4: f32,
    pub convert_k5: f32,
}

impl GraphicsIntermediateUniformsCombine {
    pub const EMPTY: Self = GraphicsIntermediateUniformsCombine {
        prim_color: glam::Vec4::ZERO,
        env_color: glam::Vec4::ZERO,
        key_center: glam::Vec3::ZERO,
        key_scale: glam::Vec3::ZERO,
        prim_lod: glam::Vec2::ZERO,
        convert_k4: 0.0,
        convert_k5: 0.0,
    };
}

#[derive(Debug, Clone, Copy)]
pub struct GraphicsIntermediateUniforms {
    pub blend: GraphicsIntermediateUniformsBlend,
    pub combine: GraphicsIntermediateUniformsCombine,
}

impl GraphicsIntermediateUniforms {
    pub const EMPTY: Self = GraphicsIntermediateUniforms {
        blend: GraphicsIntermediateUniformsBlend::EMPTY,
        combine: GraphicsIntermediateUniformsCombine::EMPTY,
    };
}

#[derive(Debug, Clone)]
pub struct GraphicsIntermediateVBO {
    pub vbo: Vec<u8>,
    pub num_tris: usize,
}

impl GraphicsIntermediateVBO {
    pub const EMPTY: Self = GraphicsIntermediateVBO {
        vbo: Vec::new(),
        num_tris: 0,
    };
}

#[derive(Debug, Clone)]
pub struct GraphicsIntermediateFogParams {
    pub multiplier: i16,
    pub offset: i16,
}

impl GraphicsIntermediateFogParams {
    pub const EMPTY: Self = GraphicsIntermediateFogParams {
        multiplier: 0,
        offset: 0,
    };
}

#[derive(Debug, Clone)]
pub struct GraphicsDrawCall {
    // Shader Configuration
    pub other_mode_h: u32,
    pub other_mode_l: u32,
    pub geometry_mode: u32,
    pub combine: CombineParams,
    pub tile_descriptors: [TileDescriptor; NUM_TILE_DESCRIPTORS],
    pub shader_hash: u64,

    // Textures
    pub textures: [Option<u64>; 2],

    // Samplers
    pub samplers: [Option<GraphicsIntermediateSampler>; 2],

    // Stencil
    pub stencil: Option<GraphicsIntermediateStencil>,

    // Viewport
    pub viewport: glam::Vec4,

    // Scissor
    pub scissor: [u32; 4],

    // Blend State
    pub blend_state: Option<BlendState>,

    // Cull Mode
    pub cull_mode: Option<Face>,

    // Uniforms
    pub uniforms: GraphicsIntermediateUniforms,

    // Triangle Data
    pub vbo: GraphicsIntermediateVBO,

    // Projection Matrix
    pub projection_matrix: glam::Mat4,

    // Fog Params
    pub fog: GraphicsIntermediateFogParams,
}

impl GraphicsDrawCall {
    pub const EMPTY: Self = GraphicsDrawCall {
        other_mode_h: 0,
        other_mode_l: 0,
        geometry_mode: 0,
        combine: CombineParams::ZERO,
        tile_descriptors: [TileDescriptor::EMPTY; NUM_TILE_DESCRIPTORS],
        shader_hash: 0,
        textures: [None; 2],
        samplers: [None; 2],
        stencil: None,
        viewport: glam::Vec4::ZERO,
        scissor: [0; 4],
        blend_state: None,
        cull_mode: None,
        uniforms: GraphicsIntermediateUniforms::EMPTY,
        vbo: GraphicsIntermediateVBO::EMPTY,
        projection_matrix: glam::Mat4::ZERO,
        fog: GraphicsIntermediateFogParams::EMPTY,
    };

    pub fn finalize(&mut self) {
        // compute the shader hash and store it
        let mut hasher = DefaultHasher::new();

        self.other_mode_h.hash(&mut hasher);
        self.other_mode_l.hash(&mut hasher);
        self.geometry_mode.hash(&mut hasher);
        self.combine.hash(&mut hasher);

        self.shader_hash = hasher.finish();
    }
}

pub struct GraphicsIntermediateDevice {
    pub texture_cache: TextureCache,
    pub draw_calls: Vec<GraphicsDrawCall>,
}

impl Default for GraphicsIntermediateDevice {
    fn default() -> Self {
        Self::new()
    }
}

impl GraphicsIntermediateDevice {
    pub fn new() -> Self {
        GraphicsIntermediateDevice {
            texture_cache: TextureCache::new(TEXTURE_CACHE_MAX_SIZE),
            // start draw calls with a default draw call
            draw_calls: vec![GraphicsDrawCall::EMPTY],
        }
    }

    fn current_draw_call(&mut self) -> &mut GraphicsDrawCall {
        self.draw_calls.last_mut().unwrap()
    }

    fn new_draw_call(&mut self) {
        let draw_call = self.current_draw_call();
        let draw_call = draw_call.clone();
        self.draw_calls.push(draw_call);
    }

    // Public API

    pub fn clear_draw_calls(&mut self) {
        let draw_call = self.current_draw_call();
        let draw_call = draw_call.clone();
        self.draw_calls = vec![draw_call];
    }

    pub fn clear_textures(&mut self, index: usize) {
        let draw_call = self.current_draw_call();
        draw_call.textures[index] = None;
    }

    pub fn set_program_params(
        &mut self,
        other_mode_h: u32,
        other_mode_l: u32,
        combine: CombineParams,
        tile_descriptors: [TileDescriptor; NUM_TILE_DESCRIPTORS],
    ) {
        let draw_call = self.current_draw_call();
        draw_call.other_mode_h = other_mode_h;
        draw_call.other_mode_l = other_mode_l;
        draw_call.combine = combine;
        draw_call.tile_descriptors = tile_descriptors;
    }

    pub fn set_texture(&mut self, tile: usize, hash: u64) {
        let draw_call = self.current_draw_call();
        draw_call.textures[tile] = Some(hash);
    }

    pub fn set_sampler_parameters(
        &mut self,
        tile: usize,
        linear_filter: bool,
        clamp_s: u32,
        clamp_t: u32,
    ) {
        let draw_call = self.current_draw_call();
        draw_call.samplers[tile] = Some(GraphicsIntermediateSampler {
            tile,
            linear_filter,
            clamp_s,
            clamp_t,
        });
    }

    pub fn set_depth_stencil_params(
        &mut self,
        _depth_test_enabled: bool,
        depth_write_enabled: bool,
        depth_compare: CompareFunction,
        polygon_offset: bool,
    ) {
        let draw_call = self.current_draw_call();
        draw_call.stencil = Some(GraphicsIntermediateStencil {
            depth_write_enabled,
            depth_compare,
            polygon_offset,
        });
    }

    pub fn set_projection_matrix(&mut self, matrix: glam::Mat4) {
        let draw_call = self.current_draw_call();
        draw_call.projection_matrix = matrix;
    }

    pub fn set_fog(&mut self, multiplier: i16, offset: i16) {
        let draw_call = self.current_draw_call();
        draw_call.fog = GraphicsIntermediateFogParams { multiplier, offset };
    }

    pub fn set_viewport(&mut self, x: f32, y: f32, width: f32, height: f32) {
        let draw_call = self.current_draw_call();
        draw_call.viewport = glam::Vec4::new(x, y, width, height);
    }

    pub fn set_scissor(&mut self, x: u32, y: u32, width: u32, height: u32) {
        let draw_call = self.current_draw_call();
        draw_call.scissor = [x, y, width, height];
    }

    pub fn set_blend_state(&mut self, blend_state: Option<BlendState>) {
        let draw_call = self.current_draw_call();
        draw_call.blend_state = blend_state;
    }

    pub fn set_cull_mode(&mut self, cull_mode: Option<Face>) {
        let draw_call = self.current_draw_call();
        draw_call.cull_mode = cull_mode;
    }

    pub fn set_uniforms(
        &mut self,
        fog_color: glam::Vec4,
        blend_color: glam::Vec4,
        prim_color: glam::Vec4,
        env_color: glam::Vec4,
        key_center: glam::Vec3,
        key_scale: glam::Vec3,
        prim_lod: glam::Vec2,
        convert_k: [i32; 6],
    ) {
        let draw_call = self.current_draw_call();
        draw_call.uniforms = GraphicsIntermediateUniforms {
            blend: GraphicsIntermediateUniformsBlend {
                fog_color,
                blend_color,
            },
            combine: GraphicsIntermediateUniformsCombine {
                prim_color,
                env_color,
                key_center,
                key_scale,
                prim_lod,
                convert_k4: convert_k[4] as f32 / 255.0,
                convert_k5: convert_k[5] as f32 / 255.0,
            },
        };
    }

    pub fn set_vbo(&mut self, vbo: Vec<u8>, num_tris: usize) {
        let draw_call = self.current_draw_call();
        draw_call.vbo = GraphicsIntermediateVBO { vbo, num_tris };
        draw_call.finalize();

        // start a new draw call that's a copy of the current one
        // we do this cause atm we only set properties on changes
        self.new_draw_call();
    }
}
